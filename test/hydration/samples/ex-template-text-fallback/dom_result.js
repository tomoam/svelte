/* Nested.svelte generated by Svelte v3.40.3 */
import {
    SvelteComponent,
    append_hydration,
    children,
    claim_element,
    claim_space,
    claim_text,
    create_slot,
    detach,
    element,
    get_all_dirty_from_scope,
    get_slot_changes,
    init,
    insert_hydration,
    safe_not_equal,
    space,
    text,
    transition_in,
    transition_out,
    update_slot_base
} from "svelte/internal";

const get_foo_slot_changes = dirty => ({});
const get_foo_slot_context = ctx => ({});

// (2:18)    foo fallback  
function fallback_block(ctx) {
    let t;

    return {
        c() {
            t = text("foo fallback");
        },
        l(nodes) {
            t = claim_text(nodes, "foo fallback");
        },
        m(target, anchor) {
            insert_hydration(target, t, anchor);
        },
        d(detaching) {
            if (detaching) detach(t);
        }
    };
}

function create_fragment(ctx) {
    let div;
    let t;
    let current;
    const foo_slot_template = /*#slots*/ ctx[1].foo;
    const foo_slot = create_slot(foo_slot_template, ctx, /*$$scope*/ ctx[0], get_foo_slot_context);
    const foo_slot_or_fallback = foo_slot || fallback_block(ctx);
    const default_slot_template = /*#slots*/ ctx[1].default;
    const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    return {
        c() {
            div = element("div");
            if (foo_slot_or_fallback) foo_slot_or_fallback.c();
            t = space();
            if (default_slot) default_slot.c();
        },
        l(nodes) {
            div = claim_element(nodes, "DIV", {});
            var div_nodes = children(div);
            if (foo_slot_or_fallback) foo_slot_or_fallback.l(div_nodes);
            t = claim_space(div_nodes);
            if (default_slot) default_slot.l(div_nodes);
            div_nodes.forEach(detach);
        },
        m(target, anchor) {
            insert_hydration(target, div, anchor);

            if (foo_slot_or_fallback) {
                foo_slot_or_fallback.m(div, null);
            }

            append_hydration(div, t);

            if (default_slot) {
                default_slot.m(div, null);
            }

            current = true;
        },
        p(ctx, [dirty]) {
            if (foo_slot) {
                if (foo_slot.p && (!current || dirty & /*$$scope*/ 1)) {
                    update_slot_base(
                        foo_slot,
                        foo_slot_template,
                        ctx,
                        /*$$scope*/ ctx[0],
                        !current
                        ? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
                        : get_slot_changes(foo_slot_template, /*$$scope*/ ctx[0], dirty, get_foo_slot_changes),
                        get_foo_slot_context
                    );
                }
            }

            if (default_slot) {
                if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
                    update_slot_base(
                        default_slot,
                        default_slot_template,
                        ctx,
                        /*$$scope*/ ctx[0],
                        !current
                        ? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
                        : get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
                        null
                    );
                }
            }
        },
        i(local) {
            if (current) return;
            transition_in(foo_slot_or_fallback, local);
            transition_in(default_slot, local);
            current = true;
        },
        o(local) {
            transition_out(foo_slot_or_fallback, local);
            transition_out(default_slot, local);
            current = false;
        },
        d(detaching) {
            if (detaching) detach(div);
            if (foo_slot_or_fallback) foo_slot_or_fallback.d(detaching);
            if (default_slot) default_slot.d(detaching);
        }
    };
}

function instance($$self, $$props, $$invalidate) {
    let { $$slots: slots = {}, $$scope } = $$props;

    $$self.$$set = $$props => {
        if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    };

    return [$$scope, slots];
}

class Nested extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, instance, create_fragment, safe_not_equal, {});
    }
}

export default Nested;
ed.svelte

.svelte
/* main.svelte generated by Svelte v3.40.3 */
import {
    SvelteComponent,
    append_hydration,
    attr,
    children,
    claim_component,
    claim_element,
    claim_text,
    create_component,
    destroy_component,
    detach,
    element,
    init,
    insert_hydration,
    mount_component,
    safe_not_equal,
    text,
    transition_in,
    transition_out
} from "svelte/internal";

import Nested from './Nested.svelte';

function create_default_slot(ctx) {
    let t;

    return {
        c() {
            t = text("default");
        },
        l(nodes) {
            t = claim_text(nodes, "default");
        },
        m(target, anchor) {
            insert_hydration(target, t, anchor);
        },
        d(detaching) {
            if (detaching) detach(t);
        }
    };
}

// (6:1) 
function create_foo_slot(ctx) {
    let div;
    let t;

    return {
        c() {
            div = element("div");
            t = text("foo override");
            this.h();
        },
        l(nodes) {
            div = claim_element(nodes, "DIV", { slot: true });
            var div_nodes = children(div);
            t = claim_text(div_nodes, "foo override");
            div_nodes.forEach(detach);
            this.h();
        },
        h() {
            attr(div, "slot", "foo");
        },
        m(target, anchor) {
            insert_hydration(target, div, anchor);
            append_hydration(div, t);
        },
        d(detaching) {
            if (detaching) detach(div);
        }
    };
}

function create_fragment(ctx) {
    let nested;
    let current;

    nested = new Nested({
            props: {
                $$slots: {
                    foo: [create_foo_slot],
                    default: [create_default_slot]
                },
                $$scope: { ctx }
            }
        });

    return {
        c() {
            create_component(nested.$$.fragment);
        },
        l(nodes) {
            claim_component(nested.$$.fragment, nodes);
        },
        m(target, anchor) {
            mount_component(nested, target, anchor);
            current = true;
        },
        p(ctx, [dirty]) {
            const nested_changes = {};

            if (dirty & /*$$scope*/ 1) {
                nested_changes.$$scope = { dirty, ctx };
            }

            nested.$set(nested_changes);
        },
        i(local) {
            if (current) return;
            transition_in(nested.$$.fragment, local);
            current = true;
        },
        o(local) {
            transition_out(nested.$$.fragment, local);
            current = false;
        },
        d(detaching) {
            destroy_component(nested, detaching);
        }
    };
}

class Main extends SvelteComponent {
    constructor(options) {
        super();
        init(this, options, null, create_fragment, safe_not_equal, {});
    }
}

export default Main;