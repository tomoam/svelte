/* generated by Svelte vX.Y.Z */
import {
	SvelteComponent,
	attr,
	destroy_block,
	detach,
	first_child,
	first_element_child,
	init,
	insert_experimental,
	listen,
	make_renderer,
	next_element_sibling,
	next_sibling,
	noop,
	replace_blank,
	replace_text,
	run_all,
	safe_not_equal,
	set_data,
	update_keyed_each
} from "svelte/internal";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[17] = list;
	child_ctx[18] = i;
	return child_ctx;
}

const render_3 = make_renderer(`<section class="main"><input id="toggle-all" class="toggle-all" type="checkbox"> <label for="toggle-all">Mark all as complete</label> <ul class="todo-list"><!></ul> <footer class="footer"><span class="todo-count"><strong><!></strong> <!> left</span> <ul class="filters"><li><a href="#/">All</a></li> <li><a href="#/active">Active</a></li> <li><a href="#/completed">Completed</a></li></ul> <!></footer></section>`);

// (98:0) {#if items.length > 0}
function create_if_block(ctx) {
	let section;
	let input;
	let input_checked_value;
	let label;
	let ul0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let footer;
	let span;
	let strong;
	let t4;
	let t5;
	let t6_value = (/*numActive*/ ctx[4] === 1 ? 'item' : 'items') + "";
	let t6;
	let ul1;
	let li0;
	let a0;
	let a0_class_value;
	let li1;
	let a1;
	let a1_class_value;
	let li2;
	let a2;
	let a2_class_value;
	let t14;
	let if_block_anchor;
	let mounted;
	let dispose;
	let each_value = /*filtered*/ ctx[5];
	const get_key = ctx => /*item*/ ctx[16].id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	let if_block = /*numCompleted*/ ctx[3] && create_if_block_1(ctx);

	return {
		c() {
			section = first_child(render_3());
			input = first_element_child(section);
			label = next_element_sibling(input);
			ul0 = next_element_sibling(label);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = replace_blank(first_child(ul0));
			footer = next_element_sibling(ul0);
			span = first_element_child(footer);
			strong = first_element_child(span);
			t4 = replace_text(first_child(strong), /*numActive*/ ctx[4]);
			t5 = next_sibling(strong);
			t6 = replace_text(next_sibling(t5), t6_value);
			ul1 = next_element_sibling(span);
			li0 = first_element_child(ul1);
			a0 = first_element_child(li0);
			li1 = next_element_sibling(li0);
			a1 = first_element_child(li1);
			li2 = next_element_sibling(li1);
			a2 = first_element_child(li2);
			t14 = next_sibling(ul1);
			if_block_anchor = replace_blank(next_sibling(t14));
			if (if_block) if_block.c();
			input.checked = input_checked_value = /*numCompleted*/ ctx[3] === /*items*/ ctx[1].length;
			attr(a0, "class", a0_class_value = /*currentFilter*/ ctx[0] === 'all' ? 'selected' : '');
			attr(a1, "class", a1_class_value = /*currentFilter*/ ctx[0] === 'active' ? 'selected' : '');

			attr(a2, "class", a2_class_value = /*currentFilter*/ ctx[0] === 'completed'
			? 'selected'
			: '');
		},
		m(target, anchor) {
			insert_experimental(target, section, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul0, null);
			}

			if (if_block) if_block.m(footer, null);

			if (!mounted) {
				dispose = listen(input, "change", /*toggleAll*/ ctx[8]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*numCompleted, items*/ 10 && input_checked_value !== (input_checked_value = /*numCompleted*/ ctx[3] === /*items*/ ctx[1].length)) {
				input.checked = input_checked_value;
			}

			if (dirty & /*filtered, editing, handleEdit, submit, remove*/ 3236) {
				each_value = /*filtered*/ ctx[5];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul0, destroy_block, create_each_block, null, get_each_context);
			}

			if (dirty & /*numActive*/ 16) set_data(t4, /*numActive*/ ctx[4]);
			if (dirty & /*numActive*/ 16 && t6_value !== (t6_value = (/*numActive*/ ctx[4] === 1 ? 'item' : 'items') + "")) set_data(t6, t6_value);

			if (dirty & /*currentFilter*/ 1 && a0_class_value !== (a0_class_value = /*currentFilter*/ ctx[0] === 'all' ? 'selected' : '')) {
				attr(a0, "class", a0_class_value);
			}

			if (dirty & /*currentFilter*/ 1 && a1_class_value !== (a1_class_value = /*currentFilter*/ ctx[0] === 'active' ? 'selected' : '')) {
				attr(a1, "class", a1_class_value);
			}

			if (dirty & /*currentFilter*/ 1 && a2_class_value !== (a2_class_value = /*currentFilter*/ ctx[0] === 'completed'
			? 'selected'
			: '')) {
				attr(a2, "class", a2_class_value);
			}

			if (/*numCompleted*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(footer, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(section);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

const render_1 = make_renderer(`<input id="edit" class="edit" autofocus>`);

// (112:5) {#if editing === index}
function create_if_block_2(ctx) {
	let input;
	let input_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = first_child(render_1());
			input.value = input_value_value = /*item*/ ctx[16].description;
			input.autofocus = true;
		},
		m(target, anchor) {
			insert_experimental(target, input, anchor);
			input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "keydown", /*handleEdit*/ ctx[10]),
					listen(input, "blur", /*submit*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*filtered*/ 32 && input_value_value !== (input_value_value = /*item*/ ctx[16].description) && input.value !== input_value_value) {
				input.value = input_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

const render_2 = make_renderer(`<li><div class="view"><input class="toggle" type="checkbox"> <label><!></label> <button class="destroy"></button></div> <!> </li>`);

// (104:3) {#each filtered as item, index (item.id)}
function create_each_block(key_1, ctx) {
	let li;
	let div;
	let input;
	let label;
	let t1_value = /*item*/ ctx[16].description + "";
	let t1;
	let button;
	let t3;
	let if_block_anchor;
	let t4;
	let li_class_value;
	let mounted;
	let dispose;

	function input_change_handler() {
		/*input_change_handler*/ ctx[12].call(input, /*each_value*/ ctx[17], /*index*/ ctx[18]);
	}

	function dblclick_handler() {
		return /*dblclick_handler*/ ctx[13](/*index*/ ctx[18]);
	}

	function click_handler() {
		return /*click_handler*/ ctx[14](/*index*/ ctx[18]);
	}

	let if_block = /*editing*/ ctx[2] === /*index*/ ctx[18] && create_if_block_2(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			li = first_child(render_2());
			div = first_element_child(li);
			input = first_element_child(div);
			label = next_element_sibling(input);
			t1 = replace_text(first_child(label), t1_value);
			button = next_element_sibling(label);
			t3 = next_sibling(div);
			if_block_anchor = replace_blank(next_sibling(t3));
			if (if_block) if_block.c();
			t4 = next_sibling(if_block_anchor);

			attr(li, "class", li_class_value = "" + ((/*item*/ ctx[16].completed ? 'completed' : '') + " " + (/*editing*/ ctx[2] === /*index*/ ctx[18]
			? 'editing'
			: '')));

			this.first = li;
		},
		m(target, anchor) {
			insert_experimental(target, li, anchor);
			input.checked = /*item*/ ctx[16].completed;
			if (if_block) if_block.m(li, t4);

			if (!mounted) {
				dispose = [
					listen(input, "change", input_change_handler),
					listen(label, "dblclick", dblclick_handler),
					listen(button, "click", click_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*filtered*/ 32) {
				input.checked = /*item*/ ctx[16].completed;
			}

			if (dirty & /*filtered*/ 32 && t1_value !== (t1_value = /*item*/ ctx[16].description + "")) set_data(t1, t1_value);

			if (/*editing*/ ctx[2] === /*index*/ ctx[18]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(li, t4);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*filtered, editing*/ 36 && li_class_value !== (li_class_value = "" + ((/*item*/ ctx[16].completed ? 'completed' : '') + " " + (/*editing*/ ctx[2] === /*index*/ ctx[18]
			? 'editing'
			: '')))) {
				attr(li, "class", li_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

const render = make_renderer(`<button class="clear-completed">Clear completed</button>`);

// (137:3) {#if numCompleted}
function create_if_block_1(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = first_child(render());
		},
		m(target, anchor) {
			insert_experimental(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*clearCompleted*/ ctx[6]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

const render_4 = make_renderer(`<header class="header"><h1>todos</h1> <input class="new-todo" placeholder="What needs to be done?" autofocus></header> <!>`);

function create_fragment(ctx) {
	let header;
	let h1;
	let input;
	let t2;
	let if_block_anchor;
	let mounted;
	let dispose;
	let if_block = /*items*/ ctx[1].length > 0 && create_if_block(ctx);

	return {
		c() {
			header = first_child(render_4());
			h1 = first_element_child(header);
			input = next_element_sibling(h1);
			t2 = next_sibling(header);
			if_block_anchor = replace_blank(next_sibling(t2));
			if (if_block) if_block.c();
			input.autofocus = true;
		},
		m(target, anchor) {
			insert_experimental(target, header, anchor);
			insert_experimental(target, t2, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_experimental(target, if_block_anchor, anchor);
			input.focus();

			if (!mounted) {
				dispose = listen(input, "keydown", /*createNew*/ ctx[9]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*items*/ ctx[1].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(header);
			if (detaching) detach(t2);
			if (detaching) detach(if_block_anchor);
			if (if_block) if_block.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

const ENTER_KEY = 13;
const ESCAPE_KEY = 27;

function uuid() {
	return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').replace(/[xy]/g, function (c) {
		var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;
		return v.toString(16);
	});
}

function instance($$self, $$props, $$invalidate) {
	let filtered;
	let numActive;
	let numCompleted;
	let currentFilter = 'all';
	let items = [];
	let editing = null;

	try {
		items = JSON.parse(localStorage.getItem('todos-svelte')) || [];
	} catch(err) {
		items = [];
	}

	const updateView = () => {
		$$invalidate(0, currentFilter = 'all');

		if (window.location.hash === '#/active') {
			$$invalidate(0, currentFilter = 'active');
		} else if (window.location.hash === '#/completed') {
			$$invalidate(0, currentFilter = 'completed');
		}
	};

	window.addEventListener('hashchange', updateView);
	updateView();

	function clearCompleted() {
		$$invalidate(1, items = items.filter(item => !item.completed));
	}

	function remove(index) {
		$$invalidate(1, items = items.slice(0, index).concat(items.slice(index + 1)));
	}

	function toggleAll(event) {
		$$invalidate(1, items = items.map(item => ({
			id: item.id,
			description: item.description,
			completed: event.target.checked
		})));
	}

	function createNew(event) {
		if (event.which === ENTER_KEY) {
			$$invalidate(1, items = items.concat({
				id: uuid(),
				description: event.target.value,
				completed: false
			}));

			event.target.value = '';
		}
	}

	function handleEdit(event) {
		if (event.which === ENTER_KEY) event.target.blur(); else if (event.which === ESCAPE_KEY) $$invalidate(2, editing = null);
	}

	function submit(event) {
		$$invalidate(1, items[editing].description = event.target.value, items);
		$$invalidate(2, editing = null);
	}

	function input_change_handler(each_value, index) {
		each_value[index].completed = this.checked;
		(($$invalidate(5, filtered), $$invalidate(0, currentFilter)), $$invalidate(1, items));
	}

	const dblclick_handler = index => $$invalidate(2, editing = index);
	const click_handler = index => remove(index);

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*currentFilter, items*/ 3) {
			$: $$invalidate(5, filtered = currentFilter === 'all'
			? items
			: currentFilter === 'completed'
				? items.filter(item => item.completed)
				: items.filter(item => !item.completed));
		}

		if ($$self.$$.dirty & /*items*/ 2) {
			$: $$invalidate(4, numActive = items.filter(item => !item.completed).length);
		}

		if ($$self.$$.dirty & /*items*/ 2) {
			$: $$invalidate(3, numCompleted = items.filter(item => item.completed).length);
		}

		if ($$self.$$.dirty & /*items*/ 2) {
			$: try {
				localStorage.setItem('todos-svelte', JSON.stringify(items));
			} catch(err) {
				
			} // noop
		}
	};

	return [
		currentFilter,
		items,
		editing,
		numCompleted,
		numActive,
		filtered,
		clearCompleted,
		remove,
		toggleAll,
		createNew,
		handleEdit,
		submit,
		input_change_handler,
		dblclick_handler,
		click_handler
	];
}

class Component extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Component;